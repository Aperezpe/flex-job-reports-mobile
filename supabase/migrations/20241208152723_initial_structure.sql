create table "public"."addresses" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "address_title" text,
    "address_street" text not null,
    "address_street_2" character varying,
    "address_city" character varying,
    "address_state" character varying,
    "address_zip_code" character varying,
    "client_id" bigint not null
);


alter table "public"."addresses" enable row level security;

create table "public"."clients" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "client_name" text not null,
    "client_company_name" text,
    "client_phone_number" character varying,
    "company_id" uuid
);


alter table "public"."clients" enable row level security;

create table "public"."companies" (
    "created_at" timestamp with time zone not null default now(),
    "company_name" text not null,
    "system_types" character varying[],
    "admin_id" uuid not null,
    "forms" jsonb,
    "id" uuid not null default gen_random_uuid(),
    "company_uid" character varying not null
);


alter table "public"."companies" enable row level security;

create table "public"."job_reports" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "system_id" bigint not null,
    "job_report" jsonb not null,
    "client_id" bigint not null
);


alter table "public"."job_reports" enable row level security;

create table "public"."systems" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "system_name" text not null,
    "system_type" character varying,
    "address_id" bigint not null,
    "area" character varying,
    "tonnage" real,
    "last_service" timestamp with time zone
);


alter table "public"."systems" enable row level security;

create table "public"."users" (
    "id" uuid not null,
    "updated_at" timestamp without time zone not null default CURRENT_TIMESTAMP,
    "full_name" text default ''::text,
    "status" character varying,
    "company_id" uuid,
    "phone_number" character varying
);


alter table "public"."users" enable row level security;

CREATE UNIQUE INDEX addresses_pkey ON public.addresses USING btree (id);

CREATE UNIQUE INDEX clients_pkey ON public.clients USING btree (id);

CREATE UNIQUE INDEX companies_company_uid_key ON public.companies USING btree (company_uid);

CREATE UNIQUE INDEX companies_id_key ON public.companies USING btree (id);

CREATE UNIQUE INDEX companies_pkey ON public.companies USING btree (id);

CREATE UNIQUE INDEX service_jobs_pkey ON public.job_reports USING btree (id);

CREATE UNIQUE INDEX systems_pkey ON public.systems USING btree (id);

CREATE UNIQUE INDEX users_pkey ON public.users USING btree (id);

alter table "public"."addresses" add constraint "addresses_pkey" PRIMARY KEY using index "addresses_pkey";

alter table "public"."clients" add constraint "clients_pkey" PRIMARY KEY using index "clients_pkey";

alter table "public"."companies" add constraint "companies_pkey" PRIMARY KEY using index "companies_pkey";

alter table "public"."job_reports" add constraint "service_jobs_pkey" PRIMARY KEY using index "service_jobs_pkey";

alter table "public"."systems" add constraint "systems_pkey" PRIMARY KEY using index "systems_pkey";

alter table "public"."users" add constraint "users_pkey" PRIMARY KEY using index "users_pkey";

alter table "public"."addresses" add constraint "addresses_client_id_fkey" FOREIGN KEY (client_id) REFERENCES clients(id) ON DELETE CASCADE not valid;

alter table "public"."addresses" validate constraint "addresses_client_id_fkey";

alter table "public"."clients" add constraint "clients_company_id_fkey" FOREIGN KEY (company_id) REFERENCES companies(id) ON DELETE CASCADE not valid;

alter table "public"."clients" validate constraint "clients_company_id_fkey";

alter table "public"."companies" add constraint "companies_admin_id_fkey" FOREIGN KEY (admin_id) REFERENCES users(id) ON DELETE CASCADE not valid;

alter table "public"."companies" validate constraint "companies_admin_id_fkey";

alter table "public"."companies" add constraint "companies_company_uid_key" UNIQUE using index "companies_company_uid_key";

alter table "public"."companies" add constraint "companies_id_key" UNIQUE using index "companies_id_key";

alter table "public"."job_reports" add constraint "service_jobs_client_id_fkey" FOREIGN KEY (client_id) REFERENCES clients(id) ON DELETE CASCADE not valid;

alter table "public"."job_reports" validate constraint "service_jobs_client_id_fkey";

alter table "public"."job_reports" add constraint "service_jobs_system_id_fkey" FOREIGN KEY (system_id) REFERENCES systems(id) not valid;

alter table "public"."job_reports" validate constraint "service_jobs_system_id_fkey";

alter table "public"."systems" add constraint "systems_address_id_fkey" FOREIGN KEY (address_id) REFERENCES addresses(id) ON DELETE CASCADE not valid;

alter table "public"."systems" validate constraint "systems_address_id_fkey";

alter table "public"."users" add constraint "users_company_id_fkey" FOREIGN KEY (company_id) REFERENCES companies(id) ON DELETE CASCADE not valid;

alter table "public"."users" validate constraint "users_company_id_fkey";

alter table "public"."users" add constraint "users_id_fkey" FOREIGN KEY (id) REFERENCES auth.users(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."users" validate constraint "users_id_fkey";

set check_function_bodies = off;

CREATE OR REPLACE FUNCTION public.handle_user_registration()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO ''
AS $function$
DECLARE
  -- Constants
  ADMIN_STATUS CONSTANT TEXT := 'ADMIN';
  PENDING_STATUS CONSTANT TEXT := 'PENDING';
  -- Variables
  new_company_id UUID;  -- ID of the newly created company
  existing_company_id UUID; -- ID of the fetched existing company
  user_meta_data JSONB; -- To extract user meta data
  user_full_name TEXT; -- to extract full name coming from client
  user_phone TEXT; -- To extract phone number coming from client
  company_uid TEXT; -- To extract Company UID coming from client
  company_name TEXT; -- To extract Company Name coming from client
  user_status TEXT; -- To extract 'status' from user metadata
BEGIN
  -- Extract user metadata status
  SELECT raw_user_meta_data
  INTO user_meta_data
  FROM auth.users
  WHERE id = NEW.id;
  
  IF user_meta_data is null then
    raise exception 'user_meta_data is null!';
  end if;
  user_full_name := user_meta_data->>'fullName';
  user_phone := user_meta_data->>'phoneNumber';
  company_uid := user_meta_data->>'companyUID';
  company_name := user_meta_data->>'companyName';
  user_status := user_meta_data->>'status';
  raise log 'user_full_name: %', user_full_name;
  raise log 'user_phone: %', user_phone;
  raise log 'company_uid: %', company_uid;
  raise log 'company_name: %', company_name;
  raise log 'user_status: %', user_status;
  
  -- Case 1: If the user is an admin
  IF user_status = ADMIN_STATUS THEN
    raise log 'Registering a Company Admin';
    -- Step 1: Insert the User (without the company_id for now)
    INSERT INTO public.users (id, full_name, status)
    VALUES (NEW.id, user_full_name, user_status);
    -- Step 2: Insert the Company, with the user ID as the admin_id
    INSERT INTO public.companies (company_name, company_uid, admin_id)
    VALUES (company_name, company_uid, NEW.id)
    RETURNING id INTO new_company_id;
    -- Step 3: Update the User to set the company_id (linking the user to the company)
    UPDATE public.users
    SET company_id = new_company_id
    WHERE id = NEW.id;
  ELSE
    raise log 'Registering a Technician';
    -- Case 2: If the user is a technician
    -- Fetch the ID of the existing company (customize as needed)
    SELECT id
    INTO existing_company_id
    FROM public.companies
    WHERE company_uid = company_uid; -- Replace with actual logic for selecting the company
    -- Ensure the company exists
    IF existing_company_id IS NULL THEN
      RAISE EXCEPTION 'psql: The entered company id does not exist!';
    END IF;
    -- Insert the user with the existing company's ID
    INSERT INTO public.users (id, full_name, status, company_id)
    VALUES (NEW.id, user_full_name, PENDING_STATUS, existing_company_id);
  END IF;
  -- Prevent modifying the auth.users table row
  RETURN NULL;
END;
$function$
;

grant delete on table "public"."addresses" to "anon";

grant insert on table "public"."addresses" to "anon";

grant references on table "public"."addresses" to "anon";

grant select on table "public"."addresses" to "anon";

grant trigger on table "public"."addresses" to "anon";

grant truncate on table "public"."addresses" to "anon";

grant update on table "public"."addresses" to "anon";

grant delete on table "public"."addresses" to "authenticated";

grant insert on table "public"."addresses" to "authenticated";

grant references on table "public"."addresses" to "authenticated";

grant select on table "public"."addresses" to "authenticated";

grant trigger on table "public"."addresses" to "authenticated";

grant truncate on table "public"."addresses" to "authenticated";

grant update on table "public"."addresses" to "authenticated";

grant delete on table "public"."addresses" to "service_role";

grant insert on table "public"."addresses" to "service_role";

grant references on table "public"."addresses" to "service_role";

grant select on table "public"."addresses" to "service_role";

grant trigger on table "public"."addresses" to "service_role";

grant truncate on table "public"."addresses" to "service_role";

grant update on table "public"."addresses" to "service_role";

grant delete on table "public"."clients" to "anon";

grant insert on table "public"."clients" to "anon";

grant references on table "public"."clients" to "anon";

grant select on table "public"."clients" to "anon";

grant trigger on table "public"."clients" to "anon";

grant truncate on table "public"."clients" to "anon";

grant update on table "public"."clients" to "anon";

grant delete on table "public"."clients" to "authenticated";

grant insert on table "public"."clients" to "authenticated";

grant references on table "public"."clients" to "authenticated";

grant select on table "public"."clients" to "authenticated";

grant trigger on table "public"."clients" to "authenticated";

grant truncate on table "public"."clients" to "authenticated";

grant update on table "public"."clients" to "authenticated";

grant delete on table "public"."clients" to "service_role";

grant insert on table "public"."clients" to "service_role";

grant references on table "public"."clients" to "service_role";

grant select on table "public"."clients" to "service_role";

grant trigger on table "public"."clients" to "service_role";

grant truncate on table "public"."clients" to "service_role";

grant update on table "public"."clients" to "service_role";

grant delete on table "public"."companies" to "anon";

grant insert on table "public"."companies" to "anon";

grant references on table "public"."companies" to "anon";

grant select on table "public"."companies" to "anon";

grant trigger on table "public"."companies" to "anon";

grant truncate on table "public"."companies" to "anon";

grant update on table "public"."companies" to "anon";

grant delete on table "public"."companies" to "authenticated";

grant insert on table "public"."companies" to "authenticated";

grant references on table "public"."companies" to "authenticated";

grant select on table "public"."companies" to "authenticated";

grant trigger on table "public"."companies" to "authenticated";

grant truncate on table "public"."companies" to "authenticated";

grant update on table "public"."companies" to "authenticated";

grant delete on table "public"."companies" to "service_role";

grant insert on table "public"."companies" to "service_role";

grant references on table "public"."companies" to "service_role";

grant select on table "public"."companies" to "service_role";

grant trigger on table "public"."companies" to "service_role";

grant truncate on table "public"."companies" to "service_role";

grant update on table "public"."companies" to "service_role";

grant delete on table "public"."job_reports" to "anon";

grant insert on table "public"."job_reports" to "anon";

grant references on table "public"."job_reports" to "anon";

grant select on table "public"."job_reports" to "anon";

grant trigger on table "public"."job_reports" to "anon";

grant truncate on table "public"."job_reports" to "anon";

grant update on table "public"."job_reports" to "anon";

grant delete on table "public"."job_reports" to "authenticated";

grant insert on table "public"."job_reports" to "authenticated";

grant references on table "public"."job_reports" to "authenticated";

grant select on table "public"."job_reports" to "authenticated";

grant trigger on table "public"."job_reports" to "authenticated";

grant truncate on table "public"."job_reports" to "authenticated";

grant update on table "public"."job_reports" to "authenticated";

grant delete on table "public"."job_reports" to "service_role";

grant insert on table "public"."job_reports" to "service_role";

grant references on table "public"."job_reports" to "service_role";

grant select on table "public"."job_reports" to "service_role";

grant trigger on table "public"."job_reports" to "service_role";

grant truncate on table "public"."job_reports" to "service_role";

grant update on table "public"."job_reports" to "service_role";

grant delete on table "public"."systems" to "anon";

grant insert on table "public"."systems" to "anon";

grant references on table "public"."systems" to "anon";

grant select on table "public"."systems" to "anon";

grant trigger on table "public"."systems" to "anon";

grant truncate on table "public"."systems" to "anon";

grant update on table "public"."systems" to "anon";

grant delete on table "public"."systems" to "authenticated";

grant insert on table "public"."systems" to "authenticated";

grant references on table "public"."systems" to "authenticated";

grant select on table "public"."systems" to "authenticated";

grant trigger on table "public"."systems" to "authenticated";

grant truncate on table "public"."systems" to "authenticated";

grant update on table "public"."systems" to "authenticated";

grant delete on table "public"."systems" to "service_role";

grant insert on table "public"."systems" to "service_role";

grant references on table "public"."systems" to "service_role";

grant select on table "public"."systems" to "service_role";

grant trigger on table "public"."systems" to "service_role";

grant truncate on table "public"."systems" to "service_role";

grant update on table "public"."systems" to "service_role";

grant delete on table "public"."users" to "anon";

grant insert on table "public"."users" to "anon";

grant references on table "public"."users" to "anon";

grant select on table "public"."users" to "anon";

grant trigger on table "public"."users" to "anon";

grant truncate on table "public"."users" to "anon";

grant update on table "public"."users" to "anon";

grant delete on table "public"."users" to "authenticated";

grant insert on table "public"."users" to "authenticated";

grant references on table "public"."users" to "authenticated";

grant select on table "public"."users" to "authenticated";

grant trigger on table "public"."users" to "authenticated";

grant truncate on table "public"."users" to "authenticated";

grant update on table "public"."users" to "authenticated";

grant delete on table "public"."users" to "service_role";

grant insert on table "public"."users" to "service_role";

grant references on table "public"."users" to "service_role";

grant select on table "public"."users" to "service_role";

grant trigger on table "public"."users" to "service_role";

grant truncate on table "public"."users" to "service_role";

grant update on table "public"."users" to "service_role";

create policy "Allow inserts for admins only"
on "public"."companies"
as permissive
for insert
to public
with check (((auth.uid() IS NOT NULL) AND (( SELECT (users.raw_user_meta_data ->> 'status'::text)
   FROM auth.users
  WHERE (users.id = auth.uid())) = 'ADMIN'::text)));


create policy "Allow read access to company_uid"
on "public"."companies"
as permissive
for select
to public
using (true);


create policy "Enable insert for authenticated users"
on "public"."users"
as permissive
for insert
to authenticated
with check (true);


create policy "Enable users to update their own user row"
on "public"."users"
as permissive
for update
to authenticated
using ((auth.uid() = id));


create policy "Enable users to view their own data only"
on "public"."users"
as permissive
for select
to authenticated
using ((auth.uid() = id));



